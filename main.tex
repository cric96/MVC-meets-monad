\documentclass[presentation]{beamer}
\usepackage{notes_style_v3}
\usecolortheme{myct3}
\usepackage[orientation=landscape,size=custom,width=16,height=9.75,scale=0.5,debug]{beamerposter}
\usepackage{multimedia}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes.geometric,positioning,automata}
\usetikzlibrary{trees,decorations.pathmorphing,calc}
\usetikzlibrary{intersections}

\title[MVC Meets Monad]{MVC meets Monads}
\subtitle{A Functional-based design for a classic architectural pattern}

\author[G.Aguzzi]
{\textbf{Gianluca Aguzzi}}

\usepackage[backend=bibtex,style=alphabetic]{biblatex} %,citestyle=authoryear

\usepackage{pifont}
\usepackage{marvosym}
\newcommand{\demoSymbol}{{\Large \ding{249}}} %{{\Large \Faxmachine}} %{\ding{43}}%

\institute[shortinst]{\normalsize 
%\inst{1} 
\textsc{Alma Mater Studiorum}--Universit\`a di Bologna, Cesena, Italy 
}

\bibliography{biblio} 
\definecolor{pbfilling}{HTML}{ffffff}% filling color for the progress bar
%\definecolor{pbfilling}{HTML}{aaaaaa}% background color for the progress bar
\definecolor{pbbackground}{rgb}{0.36, 0.54, 0.66}

\makeatletter
\def\progressbar@progressbar{} % the progress bar
\newcount\progressbar@tmpcounta% auxiliary counter
\newcount\progressbar@tmpcountb% auxiliary counter
\newdimen\progressbar@pbht %progressbar height
\newdimen\progressbar@pbwd %progressbar width
\newdimen\progressbar@tmpdim % auxiliary dimension
\progressbar@pbwd=\paperwidth
\progressbar@pbht=0.5ex
% the progress bar
\def\progressbar@progressbar{%
    \progressbar@tmpcounta= \insertframenumber % max = ?
    \progressbar@tmpcountb=\inserttotalframenumber      
    \progressbar@tmpdim=.5\progressbar@pbwd
    \multiply\progressbar@tmpdim by \progressbar@tmpcounta
    \divide\progressbar@tmpdim by \progressbar@tmpcountb
    \progressbar@tmpdim=2\progressbar@tmpdim
  \begin{tikzpicture}[rounded corners=0,very thin]
    \shade[top color=pbbackground,bottom color=pbbackground,middle color=pbbackground]
      (0pt, 0pt) rectangle ++ (\progressbar@pbwd, \progressbar@pbht);
      \shade[draw=pbfilling,top color=pbfilling,bottom color=pbfilling,middle color=pbfilling] %
        (0pt, 0pt) rectangle ++ (\progressbar@tmpdim, \progressbar@pbht);
  \end{tikzpicture}%
}

\setbeamertemplate{headline}{%
\leavevmode%
  \vbox{
  \hbox{
    \begin{beamercolorbox}[wd=1\paperwidth,ht=0.7ex,sep=0pt,center,dp=0ex]{white}%
    \progressbar@progressbar%
    \end{beamercolorbox}%
  }
  \hbox{%
  \hypersetup{linkcolor=white}
    \begin{beamercolorbox}[wd=1.02\paperwidth,ht=2.5ex,dp=1.125ex]{headline}%
    \insertsubsectionnavigationhorizontal{\paperwidth}{\bfseries\hfill}{\hfill}
    \end{beamercolorbox}%
  }
  }
}

\let\oldcite\cite
%%% additional documents commands
\newcommand{\scafiweb}{{\sc{}ScaFi-Web}}
\newcommand{\scafi}{{\sc{}ScaFi}}
\renewcommand{\cite}[1]{{\color{blue}\oldcite{#1}}}

\begin{document}

\frame[label=coverpage,noframenumbering,plain]{
\titlepage

  \begin{center}
  Talk {@}\\
  \textbf{PPS 2021} \\
  \end{center}
}

\section{It is all about composition \cite{milewski2019category}}
\begin{frame}[fragile]{It is all about composition \cite{milewski2019category}}
\begin{itemize}
\item Humans tend to divide complex problem in multiple pieces
\item Then, solve each piece
\item Finally compose all solution to solve the initial problem
\item Functional programming is a good way to compose solution :)
\end{itemize}

%\imgv{0.3}{collective-comm.png}

\section{Lecture goals}
\end{frame}
\begin{frame}[fragile]{Lecture goals}
\begin{itemize}
\item Show an end-to-end \emph{functional} application
\item Leverage some well-consolidated functional libraries
\item Understand limitations (if any) and the improvements
\end{itemize}
\end{frame}

\section{Target application}
\begin{frame}[fragile]{Target application: Tic Tac Toe}
\imgh{0.4}{tictactoe.png}
\begin{center}
  Repository: \url{https://github.com/cric96/scala-functional-gui}
\end{center}
\end{frame}

\section{OOP Design}
\begin{frame}[fragile]{OOP Design}
\begin{block}{Everything is an object}
  \begin{itemize}
  \item Clean interface
  \item State incapsulated
  \item Side effect as methods call
  \end{itemize}
\end{block}

\end{frame}

\section{Model}
\begin{frame}[fragile]{Model}
\begin{block}{Core logic}
  \begin{itemize}
    \item Main data to describe model entities (e.g. players?)
    \item Main methods to describe the game logic
  \end{itemize}
\end{block}
\begin{lstlisting}[language=Java]
/* two players (X, O)  */
enum Player {
    X, O, None; //Or? Optional?
}
/* a board 3x3 */
interface TicTacToe {
    Player get(int X, int Y);
    TicTacToe (or void??) update(int x, int y, Player p);
    boolean isOver;
    Player getTurn;
}
\end{lstlisting}
\end{frame}

\section{View}
\begin{frame}[fragile]{View}
\begin{block}{Representation and IO boundary}
  \begin{itemize}
    \item Describe what type of data can consume (for rendering porpuse)
    \item Catch how to handle user input
    \item Ideally, View could be totaly decoupled from the model
  \end{itemize}
\end{block}
\begin{lstlisting}[language=Java]

//a la' view model
interface ViewBoard {
    List<String> getRow(int row);
    List<List<String>> getAllBoard();
}
interface View extends ClickCellSource {
    void render(ViewBoard board);
    void winner(String player);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{View}
\begin{block}{Desing pattern}
  \begin{itemize}
    \item Input handler is usally solved with the Observer \cite{gamma1995design} pattern (or also called Listener). 
    \item When is possible, during the design process, is important to identify patterns and reuse common solution :D
  \end{itemize}
\end{block}
\begin{lstlisting}[language=Java]
public interface ClickCellSource {
  void attach(Observer observer);
  interface Observer {
      void notify(int X, int Y);
  }
}
\end{lstlisting}
\end{frame}

\section{Controller}
\begin{frame}[fragile]{Controller}
\begin{block}{Goals}
  \begin{itemize}
    \item Coordinate the interation between the View and Model worlds
    \item Handle concurrency
    \item Adapt data 
  \end{itemize}
\end{block}

\begin{lstlisting}[language=Java]
public interface Game extends ClickCellSource.Observer {
  void start();
}

public class TicTacToeGame implements Game {
  private final TicTacToe ticTacToe;
  private final TicTacToeView ticTacToeView;

  public static TicTacToeGame playWith(
      final TicTacToe ticTacToe, 
      final TicTacToeView ticTacToeView) {...}
  ....

\end{lstlisting}
\end{frame}

\section{Putting all togheter}
\begin{frame}[fragile]{Putting all togheter}

\begin{lstlisting}[language=Java]
public static void main(String[] args) {
  final TicTacToeView view = SwingView.createAndShow(800, 600);
  final TicTacToe model = TicTacToeFactory.startX();
  final Game game = TicTacToeGame.playWith(model, view);
  game.start();
}
\end{lstlisting}
\begin{block}{Clean enogh, isn't it?}
  What do you think?
  \begin{itemize}
    \item What do you think?
    \item Try to rethink using "functional" abstractions
    \item (Monads? Functions? Algebric Data Type?)
    \item Let's go to the "functional" side :)
  \end{itemize}
\end{block}
\end{frame}
%%Todo

\section{Libraries}
\begin{frame}[fragile]{Libraries}

\begin{block}{\href{https://typelevel.org/cats/}{Cats} \cite{scalacats2017}}
  provides abstractions for functional programming in the Scala programming language.
\end{block}

\begin{block}{\href{https://monix.io/}{Monix}}
  high-performance Scala / Scala.js library for composing asynchronous, event-based programs.
\end{block}

\end{frame}
%%Todo
\section{Task}
\begin{frame}[fragile]{Task}

\begin{block}{Definition}
  Task represents a specification for a possibly lazy or asynchronous computation, which when executed will produce an A as a result, along with possible side-effects.
\end{block}
\begin{lstlisting}[language=Scala]
  trait Task[+A] {
    final def flatMap[B](f: A => Task[B]): Task[B] = ...
    final def map[B](f : A => B): Task[B] = ...
    //some interesting extesions
    def memoize: Task[A] = ...
}
object Task {
    def pure[A](a : A) : Task[A]
    def defer[A](a : Task[A]) : Task[A]
}
\end{lstlisting}
\begin{center}
  What does it refer you to?
\end{center}

\end{frame}

\section{Task}
\begin{frame}[fragile]{A Little task}

\begin{lstlisting}[language=Scala]
val scheduler = monix.execution.Scheduler.Implicits.global

def someComputation(data : Long) : Task[Long] = 
    Task.pure(data * 1000)

def log(value : String) : Task[Unit] = Task { println(value) }

val main = for {
  data <- someComputation(4)
  _ <- log(s"computations ends with value $data")
} yield (data)

main.runToFuture(scheduler)
\end{lstlisting}
\begin{center}
  \href{https://scalafiddle.io/sf/C4Qon6a/1}{Fiddle}
\end{center}

\end{frame}

\section{Observable}
\begin{frame}[fragile]{Observable}

\begin{block}{Definition}
A data type for modelling and processing asynchronous and reactive streaming of events with non-blocking back-pressure.
\end{block}

\begin{block}{Functional Reactive Programming}
  \begin{itemize}
    \item The program is expressed as a reaction to its inputs, or as a flow of data.
    \item We can use Observable to implement it
    \item Out of this talk, If you are interested Conal Elliot (\url{http://conal.net/}) makes a lot of materials about this topic.
  \end{itemize}
\end{block}

\end{frame}

\section{Observable}
\begin{frame}[fragile]{An example with Scala.js :)}
\begin{lstlisting}[language=Scala]
val textInput = input(placeholder := "write text here").render
//unsafe "boundary"
val subject = PublishSubject[String]() 
textInput.oninput = _ => subject.onNext(textInput.value)
val result = p.render
Fiddle.print(div(textInput), result)
//safe part
val inputStream = subject.share //API of the model
val computation = for {
  text <- inputStream
  _ <- Observable.pure(result.innerText = text)
} yield()

computation.foreachL(a => a).runToFuture
\end{lstlisting}  
\begin{center}
  \href{https://scalafiddle.io/sf/0uDr1Cr/1}{Fiddle}
\end{center}

\end{frame}

\begin{frame}[allowframebreaks]{Bibliography}
\def\bibfont{\footnotesize}
\printbibliography
\end{frame}

\end{document}


% \sizedrangedcode{\ssmall}{3}{30}{\labdir/code/code_sec1.txt} 
